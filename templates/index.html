<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamics 365 Migration</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/static/ico/favicon.ico">
    <link rel="apple-touch-icon" sizes="57x57" href="/static/ico/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/static/ico/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/static/ico/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/static/ico/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/static/ico/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/static/ico/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/static/ico/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/static/ico/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/ico/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/static/ico/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/ico/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/static/ico/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/ico/favicon-16x16.png">
    <link rel="manifest" href="/static/ico/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/static/ico/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

    <!-- Stylesheets -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.0.13/dist/css/select2.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="static/style.css"> <!-- Link to external styles.css -->

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.0.13/dist/js/select2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body class="bg-gray-100">

    <div class="container mx-auto p-4">
        <h1 id="clickableHeading" class="text-3xl font-bold text-center mb-8 cursor-pointer hover:text-blue-600">
            Impower.de - Dynamics 365 Migration
        </h1>
        <!-- API Key Form -->
        <form id="authForm" class="bg-white p-6 rounded-lg shadow-md max-w-md mx-auto">
            <div class="mb-4">
                <label for="apiKey" class="block text-sm font-medium text-gray-700">API Key:</label>
                <input type="password" id="apiKey" name="apiKey" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Enter your API key" required>
                <p class="mt-2 text-sm text-gray-500">
                    Get your API key from the Impower.de settings
                </p>
            </div>
            <button type="submit" id="authenticateBtn" class="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 transition duration-200">
                <i class="fas fa-check"></i> Connect
            </button>
        </form>
       
<div id="matchingControls" class="border-2 border-gray-300 rounded-lg bg-gray-50 mx-2 sm:mx-0" style="display: none;">
    <div class="space-y-4 p-4">
    <!-- Entity Selection and Fetch Buttons -->
    <div id="entityControls" class="flex justify-center gap-2 mt-4" style="display: none;">
        <!-- impower Entity Section -->
        <div class="bg-white p-4 rounded border text-center">
            <label for="entitySelect" class="block text-xs font-medium text-gray-600 mb-1">impower Entity</label>
            <select id="entitySelect" class="block w-full px-2 py-1 border border-gray-300 rounded focus:ring-blue-500 focus:border-blue-500 text-sm">
                <option value="">-- Select --</option>
            </select>
            <button id="fetchEntityBtn" class="bg-blue-500 text-white w-full py-1 mt-2 rounded hover:bg-blue-600 text-sm">
                <i class="fas fa-download"></i> Fetch to DB and Excel
            </button>
        </div>

        <!-- CRM Entity Section -->
        <div class="bg-white p-4 rounded border text-center">
            <label for="entitySelectCRM" class="block text-xs font-medium text-gray-600 mb-1">CRM Entity</label>
            <select id="entitySelectCRM" class="block w-full px-2 py-1 border border-gray-300 rounded focus:ring-blue-500 focus:border-blue-500 text-sm">
                <option value="">-- Select --</option>
            </select>
            <button id="fetchEntityBtnCRM" class="bg-blue-500 text-white w-full py-1 mt-2 rounded hover:bg-blue-600 text-sm">
                <i class="fas fa-download"></i> Show Fields
            </button>
        </div>
    </div>

    <!-- Match Entities Button -->
    <div class="text-center" id="matchControls" style="display: none;">
        <button id="matchEntitiesBtn" class="bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 transition duration-200">
            <i class="fas fa-exchange-alt"></i> Match Entities
        </button>
    </div>

    <!-- Dropdown for Matched Fields -->
    <div class="text-center" id="matchedFieldsDropdownContainer" style="display: none;">
        <label for="matchedFieldsDropdown" class="block text-sm font-medium text-gray-700">
            Select Matched Fields:
        </label>
        <select id="matchedFieldsDropdown" multiple size="6"
            class="mt-1 block w-160 mx-auto px-3 py-2 border border-gray-400 rounded-lg shadow-md focus:outline-none focus:ring-blue-500 focus:border-blue-500">
            <!-- Options will be populated dynamically -->
        </select>
    </div>

    <!-- Save Matching Button -->
    <div class="text-center" id="saveMatchingBtnContainer" style="display: none;">
        <button id="saveMatchingBtn" class="bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 transition duration-200">
            Save Matching
        </button>
    </div>
</div>
</div>

<!-- Migration Section -->
<div id="migrationSection" class="bg-white rounded-xl shadow-md p-6 mt-8 max-w-5xl mx-auto">
    <div class="flex flex-col lg:flex-row gap-8">
        <!-- Configuration Panel -->
        <div class="flex-1">
            <div class="bg-gray-50 p-5 rounded-lg border border-gray-200">
                <h3 class="text-xl font-semibold mb-5 text-gray-800 flex items-center">
                    <i class="fas fa-cog mr-3 text-blue-500"></i>
                    Migration Configuration
                </h3>
                
                <!-- Sequence Setup Card -->
                <div class="bg-white p-4 rounded-lg shadow-sm mb-6">
                    <h4 class="text-md font-medium mb-3 text-gray-700">Migration Sequence</h4>
                    <div class="space-y-4">
                        <div>
                            <input type="text" id="sequenceName" 
                                   class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-200 focus:border-blue-400 transition"
                                   placeholder="e.g., Weekly Customer Migration">
                        </div>
                        
                        <!-- Available Entities (moved above the sequence order) -->
                        <div>
                            <label class="block text-sm font-medium text-gray-600 mb-2">Available Entitiy Pairs</label>
                            <div id="availableEntities" class="drag-container border border-gray-300 rounded-lg h-48 p-3 overflow-y-auto bg-gray-50 mb-4">
                                <!-- Will be populated from matching_table -->
                            </div>
                        </div>
                        
                        <!-- Current Sequence -->
                        <div>
                            <label class="block text-sm font-medium text-gray-600 mb-2">Migration Sequence Order</label>
                            <div id="currentSequence" class="drag-container border border-gray-300 rounded-lg h-48 p-3 overflow-y-auto bg-gray-50">
                                <!-- Will be populated by user -->
                            </div>
                        </div>
                        
                        <div class="flex justify-center space-x-3 pt-2">
                            <button id="saveSequenceBtn" 
                                    class="bg-gray-300 text-gray-500 px-5 py-2 rounded-lg flex items-center transition-colors" 
                                    disabled>
                                <i class="fas fa-save mr-2"></i> Save
                            </button>
                            <button id="deleteSequenceBtn" 
                                    class="bg-gray-300 text-gray-500 px-5 py-2 rounded-lg flex items-center transition-colors" 
                                    disabled>
                                <i class="fas fa-trash mr-2"></i> Delete
                            </button>
                        </div>
                        
                        
                    </div>
                </div>
            </div>

        </div>
        
        <!-- Execution Panel -->
        <div class="flex-1">
            <div class="bg-gray-50 p-5 rounded-lg border border-gray-200 h-full">
                <h3 class="text-xl font-semibold mb-5 text-gray-800 flex items-center">
                    <i class="fas fa-play-circle mr-3 text-green-500"></i>
                    Migration Execution
                </h3>
                
                <div class="space-y-6">
                    <!-- Sequence Selection -->
                    <div class="bg-white p-4 rounded-lg shadow-sm">
                        <h4 class="text-md font-medium mb-3 text-gray-700">Select Sequence</h4>
                        <div class="flex flex-col sm:flex-row gap-3 items-start sm:items-center">
                            <select id="selectedSequence" 
                                    class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-200 focus:border-blue-400 transition">
                                <option value="">-- Select a sequence --</option>
                                <!-- Will be populated from saved sequences -->
                            </select>
                        </div>
                    </div>
                    
                    <!-- Migration Controls -->
                    <div class="bg-white p-4 rounded-lg shadow-sm">
                        <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
                            <div class="flex items-center space-x-3">
                                <button id="migrateBtn" 
                                        class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition flex items-center text-sm sm:text-base"
                                        style="display: none;">
                                    <i class="fas fa-cogs mr-2"></i> Advanced
                                </button>

                                <button id="migrateEntityBtn" class="px-4 py-2 rounded-md font-medium transition-colors" disabled>
                                <i class="fas fa-rocket mr-2"></i>Migration
                                </button>
                            </div>
                            
                            <div class="flex items-center">
                                <input type="checkbox" id="limitRecordsCheckbox" class="h-4 w-4 text-blue-500 rounded border-gray-300 focus:ring-blue-200">
                                <label for="limitRecordsCheckbox" class="ml-2 text-sm text-gray-600">10 records</label>
                            </div>
                        </div>
                        
                    </div>
                    <!-- Compact Sequence Help Card -->
                    <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                        <div class="flex items-start gap-3">
                            <i class="fas fa-random text-blue-500 mt-1"></i>
                            <div>
                                <h4 class="font-medium text-blue-800 mb-2">Quick Migration Guide</h4>
                                <ol class="space-y-2 text-sm">
                                    <li class="flex items-start gap-2">
                                        <span class="text-blue-600 font-medium">1.</span>
                                        <span>Name your sequence (e.g. <span class="font-mono bg-blue-100 px-1.5 rounded">Monthly_Sync</span>)</span>
                                    </li>
                                    <li class="flex items-start gap-2">
                                        <span class="text-blue-600 font-medium">2.</span>
                                        <span>Drag entity pairs from <span class="text-blue-600">Available Entitiy Pairs</span> to <span class="text-blue-600">Migration Sequence Order</span></span>
                                    </li>
                                    <li class="flex items-start gap-2">
                                        <span class="text-blue-600 font-medium">3.</span>
                                        <span>Arrange by priority (top first)</span>
                                    </li>
                                    <li class="flex items-start gap-2">
                                        <span class="text-blue-600 font-medium">4.</span>
                                        <span>Click <span class="inline-flex items-center px-1.5 bg-green-100 text-green-800 rounded text-xs"><i class="fas fa-save mr-1"></i>Save</span></span>
                                    </li>
                                    <li class="flex items-start gap-2">
                                        <span class="text-blue-600 font-medium">5.</span>
                                        <span>Select from dropdown to run Migration</span>
                                    </li>
                                </ol>
                                <div class="mt-2 text-xs text-blue-700 flex items-start gap-1.5">
                                    <i class="fas fa-lightbulb mt-0.5"></i>
                                    <span><strong>Tip:</strong> Reference data first (locations - work orders)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Progress Visualization -->
                    <div id="progressContainer" class="bg-white p-4 rounded-lg shadow-sm" style="display: none;">
                        <h4 class="text-md font-medium mb-3 text-gray-700">Migration Progress</h4>
                        <div class="space-y-5">
                            <!-- Fetching Progress -->
                            <div>
                                <div class="flex justify-between mb-2">
                                    <span class="text-sm font-medium text-gray-700 flex items-center">
                                        <i class="fas fa-download mr-2 text-blue-500"></i> Fetching Data
                                    </span>
                                    <span id="fetchingMessage" class="text-xs text-gray-500">Not Started</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2.5">
                                    <div id="fetchingProgress" class="bg-blue-500 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                                </div>
                            </div>
                            
                            <!-- Migration Progress -->
                            <div>
                                <div class="flex justify-between mb-2">
                                    <span class="text-sm font-medium text-gray-700 flex items-center">
                                        <i class="fas fa-exchange-alt mr-2 text-green-500"></i> Migration Process
                                    </span>
                                    <span id="migrationMessage" class="text-xs text-gray-500">Not Started</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2.5">
                                    <div id="migrationProgress" class="bg-green-500 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
    </div>
    
</div>


<div id="metricsSection" class="border-2 border-gray-200 rounded-lg bg-gray-50 mt-8 p-4 sm:p-6" style="display: none;">
    <div class="dashboard-header text-center mb-4">
        <h3 class="dashboard-title text-xl font-bold">
            <i class="fas fa-tachometer-alt mr-2"></i>Migration Dashboard
        </h3>
        <div class="dashboard-subtitle text-sm text-gray-600">Real-time migration metrics</div>
    </div>
    
    <!-- Sequence Progress Bar -->
    <div id="sequenceProgressContainer" class="mb-4 hidden">
        <div class="flex justify-between text-xs mb-1">
            <span>Entity Pair Progress</span>
            <span id="sequenceProgressText">0/0</span>
        </div>
        <div class="w-full bg-gray-200 rounded-full h-2.5">
            <div id="sequenceProgressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
        </div>
    </div>

    <!-- Completed Pairs Accordion -->
    <div id="completedPairsAccordion" class="hidden">
        <div class="flex items-center justify-between cursor-pointer" id="completedPairsToggle">
            <h4 class="font-medium">
                <i class="fas fa-history mr-2"></i>Completed Migrations
            </h4>
            <i class="fas fa-chevron-down transition-transform" id="completedPairsChevron"></i>
        </div>
        <div id="completedPairsContainer" class="mt-2 space-y-2">
            <!-- Completed pairs will be inserted here -->
        </div>
    </div>

    <!-- Summary Section (Shown when sequence completes) -->
    <div id="sequenceSummary" class="mt-4 p-4 bg-blue-50 rounded-lg hidden">
        <div class="flex justify-between items-center">
            <div>
                <h4 class="font-bold"><i class="fas fa-flag-checkered mr-2"></i>Sequence Complete</h4>
                <div class="text-sm">Total time: <span id="totalSequenceDuration">0s</span></div>
            </div>
            <div class="text-right">
                <div class="text-xl font-bold" id="totalSequenceRecords">0</div>
                <div class="text-sm">records migrated</div>
            </div>
        </div>
    </div>
</div>


        <!-- Logs Section -->
        <div id="logsSection" class="border-2 border-gray-200 rounded-lg bg-gray-50 mt-8 p-4 sm:p-6" style="display: none;">
            <h3 class="text-xl font-semibold mb-4"><i class="fas fa-clipboard-list"></i> Logs</h3>
            <button id="toggleLogs" class="bg-gray-500 text-white py-1 px-3 rounded-md hover:bg-gray-600 transition duration-200">Show Logs</button>
            <div id="logsContainer" class="mt-4 bg-white p-4 rounded-lg shadow-md" style="display: none; max-height: 300px; overflow-y: auto;"></div>
        </div>

        <!-- Excel Download Link -->
        <div id="excelDownload" class="mt-8 max-w-2xl mx-auto text-center" style="display: none;">
            <a id="excelLink" href="#" target="_blank" class="text-blue-500 hover:text-blue-600">
                <i class="fas fa-file-excel"></i> View Excel Export
            </a>
        </div>

        <!-- CRM Link -->
        <div id="crmLinkContainer" class="mt-8 max-w-2xl mx-auto text-center" style="display: none;">
            <a id="crmLink" href="#" target="_blank" class="text-blue-500 hover:text-blue-600">Go to CRM entity</a>
        </div>

        <!-- Loading Spinner -->
        <div id="loadingSpinner" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50" style="display: none;">
            <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
        </div>
    </div>

    <script>
        let accessToken = null;

        $(document).ready(function () {

            let isDropdownChanged = false; // Flag to track dropdown changes
            const saveMatchingBtn = $("#saveMatchingBtn");
            saveMatchingBtn.hide();
            //const migrateEntityBtn = $("#migrateEntityBtn");
            //migrateEntityBtn.hide();
            const migrationSection = $("#migrationSection");
            migrationSection.hide();
            $("#matchedFieldsDropdown").select2({
                placeholder: "Select matched fields",
                allowClear: true,
                width: "65%"
                //width: "resolve"  
            });

            $("#matchedFieldsDropdown").on("change", function () {
                // Toggle the visibility of the save button based on whether any fields are selected
                $("#saveMatchingBtnContainer").toggle($(this).val().length > 0);
                isDropdownChanged = true; // Set the flag to true when dropdown changes
                saveMatchingBtn.show(); // Show the Save Matching button
            
                // Highlight the first selected option in the dropdown
                highlightFirstSelectedOption();
            });
            
            $("#matchedFieldsDropdown").on("select2:select", function (e) {
                // Highlight the first selected option in the dropdown
                highlightFirstSelectedOption();
            });
            
            $("#matchedFieldsDropdown").on("select2:unselect", function (e) {
                // Highlight the first selected option in the dropdown
                highlightFirstSelectedOption();
            });
            
            // Helper function to highlight the first selected option
            function highlightFirstSelectedOption() {
                // Reset all selected options' background color
                $("#matchedFieldsDropdown option").css("background-color", "");
            
                // Get the first selected option and highlight it
                const firstSelectedOption = $("#matchedFieldsDropdown option:selected").first();
                if (firstSelectedOption.length) {
                    firstSelectedOption.css("background-color", "yellow");
                }
            
                // Reset all Select2 choice backgrounds
                $(".select2-selection__choice").css("background-color", "");
            
                // Highlight the first Select2 choice
                const firstSelect2Choice = $(".select2-selection__choice").first();
                if (firstSelect2Choice.length) {
                    firstSelect2Choice.css("background-color", "yellow");
                }
            }

            $("#saveMatchingBtn").on("click", async function () {
                const selectedimpowerEntity = $("#entitySelect").val();
                const selectedCrmEntity = $("#entitySelectCRM").val();
                const selectedFields = $("#matchedFieldsDropdown").val();
                const logsContainer = document.getElementById("logsContainer");
                if (!selectedimpowerEntity || !selectedCrmEntity) {logsContainer.innerHTML += `<p style="color: red;">‚ùå Please select both impower and CRM entities.</p>`;autoScrollLogs();return;}            
                if (!selectedFields || selectedFields.length === 0) {logsContainer.innerHTML += `<p style="color: red;">‚ùå Please select at least one matched field.</p>`;autoScrollLogs();return;}
                const nonEmptyFields = selectedFields.filter(field => field && field.trim());
                if (nonEmptyFields.length === 0) {logsContainer.innerHTML += `<p style="color: red;">‚ùå Please select at least one valid matched field.</p>`;autoScrollLogs();return;}
                const payload = {
                    selectedimpowerEntity,
                    selectedCrmEntity,
                    matchedFields: nonEmptyFields
                };
                logsContainer.innerHTML += `<p>üì§ Sending payload: ${JSON.stringify(payload)}</p>`;            
                autoScrollLogs();            

                try {
                    const response = await fetch("/save-matching-columns", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer ${accessToken}`
                        },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();
                    if (response.ok) {
                        logsContainer.innerHTML += `<p style="color: green;">‚úÖ ${result.message}</p>`;autoScrollLogs();
                        //migrateEntityBtn.show();
                    } else {logsContainer.innerHTML += `<p style="color: red;">‚ùå Error: ${result.detail}</p>`;autoScrollLogs();
                    }
                    isDropdownChanged = false;
                    saveMatchingBtn.hide();
                    matchedFieldsDropdownContainer.style.display = "none";
                    //migrateEntityBtn.show();

        

                } catch (error) {
                    console.error("Error saving matching columns:", error);
                    logsContainer.innerHTML += `<p style="color: red;">‚ùå An error occurred while saving matching columns.</p>`;autoScrollLogs();
                }
            });
                        


            async function fetchAndDisplayMatchingFields() {
                const selectedimpowerEntity = $("#entitySelect").val();
                const selectedCrmEntity = $("#entitySelectCRM").val();
                const logsContainer = document.getElementById("logsContainer");
                //const migrateEntityBtn = $("#migrateEntityBtn");
                const matchedFieldsDropdownContainer = document.getElementById("matchedFieldsDropdownContainer");
                const matchedFieldsDropdown = document.getElementById("matchedFieldsDropdown");

                if (!selectedimpowerEntity || !selectedCrmEntity) {
                    logsContainer.innerHTML = `<strong>Please select both entities to compare.</strong>`;
                    return;
                }
            
                try {
                    $("#logsContainer").show();
                    const response = await fetch(`/get-matching-fields?selectedimpowerEntity=${selectedimpowerEntity}&selectedCrmEntity=${selectedCrmEntity}`, {
                        method: "GET",
                        headers: { "Authorization": `Bearer ${accessToken}` }
                    });
                    const result = await response.json();
            
                    if (response.ok) {
                        const matchedFields = result.matched_fields || [];
            
                        if (matchedFields.length > 0) {
                            // Show the dropdown and populate it with matched fields
                            matchedFieldsDropdown.innerHTML = ""; // Clear existing options
                            matchedFields.forEach(match => {
                                const [impowerField, crmField] = match.split("-");
                                const option = document.createElement("option");
                                option.value = match;
                                option.textContent = `${impowerField} - ${crmField}`;
                                //matchedFieldsDropdown.appendChild(option);
                                matchedFieldsDropdown.prepend(option);  
                            });
                            matchedFieldsDropdownContainer.style.display = "none"; // Hide the dropdown container

                            // Display the table with matched fields
                            let tableHTML = `
                                <strong>Comparing:</strong> 
                                <br>impower Entity: <b>${selectedimpowerEntity}</b> 
                                <br>CRM Entity: <b>${selectedCrmEntity}</b>
                                <hr>
                                <table border="1" cellspacing="0" cellpadding="5" style="width: 100%; border-collapse: collapse;">
                                    <thead>
                                        <tr style="background-color: #f2f2f2;">
                                            <th>impower Entity</th>
                                            <th>CRM Entity</th>
                                        </tr>
                                    </thead>
                                    <tbody>`;
            
                            matchedFields.forEach(match => {
                                const [impowerField, crmField] = match.split("-");
                                tableHTML += `
                                    <tr>
                                        <td>${impowerField}</td>
                                        <td>${crmField}</td>
                                    </tr>`;
                            });
            
                            tableHTML += `</tbody></table>`;
                            logsContainer.innerHTML = tableHTML;
                            //migrateEntityBtn.show();

                            
                        } else {
                            // Hide the dropdown and display a message
                            matchedFieldsDropdownContainer.style.display = "none"; // Hide the dropdown container
                            logsContainer.innerHTML = `
                                <strong>Comparing:</strong> 
                                <br>impower Entity: <b>${selectedimpowerEntity}</b> 
                                <br>CRM Entity: <b>${selectedCrmEntity}</b>
                                <hr>
                                No matching fields found.
                            `;
                            //migrateEntityBtn.hide();

                        }
            
                        autoScrollLogs();
                    } else {
                        alert(`Error: ${result.detail}`);
                    }
                } catch (error) {
                    console.error("Error fetching matching fields:", error);
                }
            }
            
            $("#entitySelect, #entitySelectCRM").on("change", fetchAndDisplayMatchingFields);
            $("#entitySelectCRM").on("change", function () {
                const selectedCrmEntity = $(this).val(); // Get the selected CRM entity
                if (selectedCrmEntity) {
                    fetchCRMEntityLink(selectedCrmEntity); // Call the function with selected value
                }
            });
            
            async function fetchEntityFields(entityName, isImpower = true) {
                const endpoint = isImpower 
                    ? `/fetch-entity-fields?entity_name=${encodeURIComponent(entityName)}`
                    : `/crm-entity-fields?entity_name=${encodeURIComponent(entityName)}`;
                
                try {
                    // Prepare base headers
                    const headers = {
                        "Accept": "application/json"
                    };
            
                    // For CRM endpoints, require and validate accessToken
                    if (!isImpower) {
                        if (!accessToken) {
                            throw new Error("Access token is required for CRM fields");
                        }
                        headers["Authorization"] = `Bearer ${accessToken}`;
                    }
            
                    const response = await fetch(endpoint, {
                        method: "GET",
                        headers: headers
                    });
            
                    // Handle 401 Unauthorized specifically
                    if (response.status === 401) {
                        throw new Error("Authentication failed - please refresh your session");
                    }
            
                    if (!response.ok) {
                        let errorDetail = `Failed to fetch ${isImpower ? 'Impower' : 'CRM'} fields`;
                        try {
                            const errorData = await response.json();
                            errorDetail = errorData.detail || errorData.message || errorDetail;
                        } catch (e) {
                            console.error("Error parsing error response:", e);
                        }
                        throw new Error(`${errorDetail} (HTTP ${response.status})`);
                    }
            
                    const data = await response.json();
                    
                    if (data.success === false) {
                        throw new Error(data.message || `No fields found for ${entityName}`);
                    }
            
                    return {
                        columns: data.columns || [],
                        sampleRecord: data.sample_record || {},
                        tableName: data.table_name || entityName.toLowerCase().replace("-", "_")
                    };
                    
                } catch (error) {
                    console.error(`Error fetching ${isImpower ? 'Impower' : 'CRM'} fields:`, error);
                    
                    // Transform specific errors for better user messaging
                    if (error.message.includes("401")) {
                        throw new Error("Session expired - please log in again");
                    }
                    if (error.message.includes("Access token is required")) {
                        throw new Error("Please authenticate to access CRM data");
                    }
                    
                    throw error;
                }
            }

// Update your matchEntitiesBtn event listener
document.getElementById("matchEntitiesBtn").addEventListener("click", async () => {
    const impowerEntitySelect = document.getElementById("entitySelect");
    const crmEntitySelect = document.getElementById("entitySelectCRM");
    const selectedImpowerEntity = impowerEntitySelect.value;
    const selectedCrmEntity = crmEntitySelect.value;

    if (!selectedImpowerEntity || !selectedCrmEntity) {
        alert("Please select both Impower and CRM entities.");
        return;
    }

    const logsContainer = document.getElementById("logsContainer");
    logsContainer.innerHTML = `<p><i class="fas fa-info-circle"></i> Matching entities: ${selectedImpowerEntity} and ${selectedCrmEntity}...</p>`;
    autoScrollLogs();
    logsContainer.style.display = "block";
    showLoadingSpinner();

    try {
        // Fetch all data in parallel
                const [
                impowerFieldsData, 
                crmFieldsData, 
                matchedFieldsData
            ] = await Promise.all([
                fetchEntityFields(selectedImpowerEntity, true),
                fetchEntityFields(selectedCrmEntity, false),
                fetch(`/get-matching-fields?selectedimpowerEntity=${encodeURIComponent(selectedImpowerEntity)}&selectedCrmEntity=${encodeURIComponent(selectedCrmEntity)}`, {
                    method: "GET",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`                    }
                }).then(async res => {
                    if (!res.ok) {
                        const error = await res.json();
                        throw new Error(error.detail || "Failed to fetch matched fields");
                    }
                    return res.json();
                })
            ]);

        // Process CRM fields with indicators for mandatory/upsert fields
        const crmFields = crmFieldsData.columns.map(column => {
            if (typeof column === 'string') return column;
            
            // Handle object-style CRM fields
            let displayName = column.name || column.fieldName || '';
            if (column.mandatory) {
                return `${displayName} *`; // Red color for required fields
            } else if (column.upsert) {
                return `${displayName} +`; // Green color for upsert fields
            }
            return displayName;
        });

        const impowerFields = impowerFieldsData.columns;
        const existingMatchedFields = matchedFieldsData.matched_fields || [];

        // Field matching logic
        const isEntirelyPartOf = (field1, field2) => {
            const cleanField1 = field1.replace(/[*+]$/, '').trim().toLowerCase();
            const cleanField2 = field2.replace(/[*+]$/, '').trim().toLowerCase();
            return cleanField2.includes(cleanField1) || cleanField1.includes(cleanField2);
        };

        const matchedFields = [];
        const uniqueImpowerFields = [];
        const uniqueCrmFields = [];

        // Generate all possible combinations for dropdown
        const allCombinations = [];
        impowerFields.forEach(impowerField => {
            crmFields.forEach(crmField => {
                const cleanImpower = impowerField.toLowerCase();
                const cleanCrm = crmField.replace(/[*+]$/, '').trim().toLowerCase();
                
                allCombinations.push({
                    impowerField,
                    crmField,
                    isExactMatch: cleanImpower === cleanCrm,
                    isPartialMatch: isEntirelyPartOf(impowerField, crmField)
                });
            });
        });

        // Find matches and unique fields
        impowerFields.forEach(impowerField => {
            let isMatched = false;
            crmFields.forEach(crmField => {
                const cleanImpower = impowerField.toLowerCase();
                const cleanCrm = crmField.replace(/[*+]$/, '').trim().toLowerCase();
                
                if (cleanImpower === cleanCrm) {
                    matchedFields.push({ 
                        impowerField, 
                        crmField, 
                        isExactMatch: true 
                    });
                    isMatched = true;
                } else if (isEntirelyPartOf(impowerField, crmField)) {
                    matchedFields.push({ 
                        impowerField, 
                        crmField, 
                        isExactMatch: false 
                    });
                    isMatched = true;
                }
            });
            
            if (!isMatched) {
                uniqueImpowerFields.push(impowerField);
            }
        });

        crmFields.forEach(crmField => {
            if (!impowerFields.some(impowerField => 
                impowerField.toLowerCase() === crmField.replace(/[*+]$/, '').trim().toLowerCase() ||
                isEntirelyPartOf(impowerField, crmField))
            ) {
                uniqueCrmFields.push(crmField);
            }
        });

        // Generate the comparison table
        let tableHtml = `
            <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px;">
                    <thead>
                        <tr style="background-color: #f8f9fa;">
                            <th style="padding: 8px; border: 1px solid #dee2e6; text-align: left;">Impower Fields</th>
                            <th style="padding: 8px; border: 1px solid #dee2e6; text-align: left;">CRM Fields</th>
                            <th style="padding: 8px; border: 1px solid #dee2e6; text-align: left;">Matched Fields</th>
                        </tr>
                    </thead>
                    <tbody>
        `;

        const maxRows = Math.max(
            uniqueImpowerFields.length, 
            uniqueCrmFields.length, 
            matchedFields.length
        );

        for (let i = 0; i < maxRows; i++) {
            const impowerField = uniqueImpowerFields[i];
            const crmField = uniqueCrmFields[i];
            const matchedField = matchedFields[i];

            tableHtml += `
                <tr>
                    <td style="padding: 8px; border: 1px solid #dee2e6;">
                        ${impowerField ? `<span style="color: #e83e8c;">‚úò ${impowerField}</span>` : ''}
                    </td>
                    <td style="padding: 8px; border: 1px solid #dee2e6;">
                        ${crmField ? `<span style="color: #007bff;">‚úò ${crmField}</span>` : ''}
                    </td>
                    <td style="padding: 8px; border: 1px solid #dee2e6;">
                        ${matchedField ? 
                            (matchedField.isExactMatch ? 
                                `<span style="color: #28a745; font-weight: bold;">‚úî ${matchedField.impowerField}</span>` : 
                                `<span style="color: #e83e8c;">${matchedField.impowerField}</span> - <span style="color: #007bff;">${matchedField.crmField}</span>`) : 
                            ''}
                    </td>
                </tr>
            `;
        }

        tableHtml += `
                    </tbody>
                </table>
            </div>
            <p style="margin-top: 10px; font-size: 12px; color: #6c757d;">
                <span style="color: #28a745;">‚úî</span> = Exact match | 
                <span style="color: #e83e8c;">-</span> = Partial match | 
                <span style="color: #e83e8c;">‚úò</span> = Unmatched Impower field | 
                <span style="color: #007bff;">‚úò</span> = Unmatched CRM field |
                <span style="color: #dc3545;">*</span> = Required CRM field |
                <span style="color: #20c997;">+</span> = Upsert CRM field
            </p>
        `;

        logsContainer.innerHTML += tableHtml;
        autoScrollLogs();

        // Populate the dropdown with field mapping options
        const matchedFieldsDropdown = document.getElementById("matchedFieldsDropdown");
        matchedFieldsDropdown.innerHTML = '<option value="">-- Select field mapping --</option>';

        allCombinations.forEach(combination => {
            const option = document.createElement("option");
            const value = `${combination.impowerField}-${combination.crmField.replace(/[*+]$/, '').trim()}`;
            option.value = value;
            
            let displayText = combination.isExactMatch
            ? `‚úî ${combination.impowerField} - ${combination.impowerField}`
            : `${combination.impowerField} - ${combination.crmField}`;
        
            if (combination.crmField.endsWith('*')) {
                displayText += '';
            } else if (combination.crmField.endsWith('+')) {
                displayText += '';
            }
            
            option.textContent = displayText;
            
            if (existingMatchedFields.includes(`${combination.faciliooField}-${combination.crmField}`)) {
                option.selected = true;
            }
            
            matchedFieldsDropdown.appendChild(option);
        });

        document.getElementById("matchedFieldsDropdownContainer").style.display = 
            allCombinations.length > 0 ? "block" : "none";

    } catch (error) {
        console.error("Error matching entities:", error);
        logsContainer.innerHTML += `
            <p style="color: #dc3545;">
                <i class="fas fa-times-circle"></i> Error: ${error.message}
            </p>
        `;
        autoScrollLogs();
    } finally {
        hideLoadingSpinner();
    }
});


// do not delete });               

    });
        

    function updatePairDashboard(pair, metrics) {
        // Update current pair dashboard
        document.getElementById('currentPairNames').textContent = `${pair.impower} - ${pair.crm}`;
        document.getElementById('currentPairRecords').textContent = metrics.totalRecords;
        document.getElementById('currentPairSuccess').textContent = `${metrics.successRate}%`;
        document.getElementById('currentPairSpeed').textContent = `${metrics.velocity}/s`;
        document.getElementById('currentPairCreated').textContent = metrics.created;
        document.getElementById('currentPairUpdated').textContent = metrics.updated;
        document.getElementById('currentPairErrors').textContent = metrics.errors;
        document.getElementById('currentPairDuration').textContent = `${metrics.duration}s`;
        
        // Update progress bars
        document.getElementById('sequenceProgressBar').style.width = `${metrics.sequenceProgress}%`;
        document.getElementById('sequenceProgressText').textContent = 
            `${metrics.sequenceCurrent}/${metrics.sequenceTotal}`;
    }
    
    function addCompletedPair(pair, metrics) {
        const container = document.getElementById('completedPairsContainer');
        const pairElement = document.createElement('div');
        pairElement.className = 'completed-pair-item';
        pairElement.innerHTML = `
            <div class="completed-pair-header">
                <span>${pair.impower} - ${pair.crm}</span>
                <span class="text-xs">${metrics.duration}s</span>
            </div>
            <div class="completed-pair-metrics">
                <div class="completed-pair-metric">
                    <span class="font-medium">${metrics.totalRecords}</span>
                    <span class="text-xs text-gray-500">Records</span>
                </div>
                <div class="completed-pair-metric">
                    <span class="font-medium ${metrics.errors > 0 ? 'text-green-600' : ''}">${metrics.successRate}%</span>
                    <span class="text-xs text-gray-500">Success</span>
                </div>
                <div class="completed-pair-metric">
                    <span class="font-medium ${metrics.errors > 0 ? 'text-red-600' : ''}">${metrics.errors}</span>
                    <span class="text-xs text-gray-500">Errors</span>
                </div>
            </div>
        `;
        container.appendChild(pairElement);
        
        // Show accordion if not already visible
        document.getElementById('completedPairsAccordion').classList.remove('hidden');
    }
    
    // Toggle completed pairs visibility
    document.getElementById('completedPairsToggle').addEventListener('click', function() {
        const container = document.getElementById('completedPairsContainer');
        const chevron = document.getElementById('completedPairsChevron');
        
        if (container.classList.contains('max-h-0')) {
            container.classList.remove('max-h-0');
            container.classList.add('max-h-[500px]');
            chevron.classList.add('rotate-180');
        } else {
            container.classList.add('max-h-0');
            container.classList.remove('max-h-[500px]');
            chevron.classList.remove('rotate-180');
        }
    });


            async function fetchCRMEntityLink(entityName) {
                try {
                    const response = await fetch(`/crm-entity-link?entity_name=${entityName}`, {
                        method: "GET",
                        headers: {
                            "Authorization": `Bearer ${localStorage.getItem("access_token")}`, // Assuming you store the token in localStorage
                            "Content-Type": "application/json"
                        }
                    });
            
                    if (!response.ok) {
                        throw new Error(`Failed to fetch CRM entity link: ${response.statusText}`);
                    }
            
                    const data = await response.json();
                    const crmLinkContainer = document.getElementById("crmLinkContainer");
                    const crmLink = document.getElementById("crmLink");
            
                    if (data.crm_entity_link) {
                        crmLink.href = data.crm_entity_link;
                        crmLinkContainer.style.display = "block";
                    } else {
                        console.error("No CRM entity link found in response");
                    }
                } catch (error) {
                    console.error("Error fetching CRM entity link:", error);
                }
            }

            document.getElementById("toggleLogs").addEventListener("click", function() {
            const logsContainer = document.getElementById("logsContainer");
            logsContainer.style.display = logsContainer.style.display === "none" ? "block" : "none";
            this.textContent = logsContainer.style.display === "none" ? "Show Logs" : "Hide Logs";
        });

        // Tooltip functionality
document.querySelectorAll('.dashboard-card').forEach(card => {
    card.addEventListener('mouseenter', function(e) {
        const tooltip = document.getElementById('formulaPopup');
        tooltip.style.left = e.pageX + 'px';
        tooltip.style.top = (e.pageY + 20) + 'px';
        tooltip.style.opacity = '1';
    });
    
    card.addEventListener('mouseleave', function() {
        document.getElementById('formulaPopup').style.opacity = '0';
    });
});


document.getElementById('completedPairsToggle').addEventListener('click', function() {
    const container = document.getElementById('completedPairsContainer');
    const chevron = document.getElementById('completedPairsChevron');
    
    if (container.classList.contains('collapsed')) {
        container.classList.remove('collapsed');
        container.classList.add('expanded');
        chevron.classList.add('rotate-180');
    } else {
        container.classList.remove('expanded');
        container.classList.add('collapsed');
        chevron.classList.remove('rotate-180');
    }
});

// Function to check if migration can be started
function checkMigrationReady() {
    const sequenceSelected = document.getElementById("selectedSequence").value;
    const migrateBtn = document.getElementById("migrateEntityBtn");
    
    // Enable button if a sequence is selected
    if (sequenceSelected) {
        migrateBtn.classList.add("active");
        migrateBtn.disabled = false;
    } else {
        // For non-sequence migration, check if both entities are selected
        const impowerEntity = $("#entitySelect").val();
        const crmEntity = $("#entitySelectCRM").val();
        
        if (impowerEntity && crmEntity) {
            migrateBtn.classList.add("active");
            migrateBtn.disabled = false;
        } else {
            migrateBtn.classList.remove("active");
            migrateBtn.disabled = true;
        }
    }
}

// Initialize button state on page load
document.addEventListener("DOMContentLoaded", function() {
    checkMigrationReady();
    
    // Add event listeners to update button state
    document.getElementById("selectedSequence").addEventListener("change", checkMigrationReady);
    document.getElementById("entitySelect").addEventListener("change", checkMigrationReady);
    document.getElementById("entitySelectCRM").addEventListener("change", checkMigrationReady);
});

document.getElementById("migrateEntityBtn").addEventListener("click", async () => {
    const logsContainer = document.getElementById("logsContainer");
    logsContainer.innerHTML = "";
    logsContainer.style.display = "block";
    document.getElementById("metricsSection").style.display = "none";
    resetProgressBars();
    showLoadingSpinner();
    const container = document.getElementById('completedPairsContainer');
    const chevron = document.getElementById('completedPairsChevron');
    
    container.classList.add('collapsed');
    chevron.classList.remove('rotate-180');

    try {
        const sequenceName = document.getElementById("selectedSequence").value;
        const limitRecords = document.getElementById("limitRecordsCheckbox").checked;
        document.getElementById("progressContainer").style.display = "block";

        // Initialize dashboard
        const metricsSection = document.getElementById("metricsSection");
        const sequenceProgressContainer = document.getElementById("sequenceProgressContainer");
        const completedPairsAccordion = document.getElementById("completedPairsAccordion");
        const sequenceSummary = document.getElementById("sequenceSummary");
        
        if (sequenceName) {
            sequenceProgressContainer.classList.remove("hidden");
            completedPairsAccordion.classList.remove("hidden");
            sequenceSummary.classList.add("hidden");
            document.getElementById("completedPairsContainer").innerHTML = "";
        } else {
            sequenceProgressContainer.classList.add("hidden");
            completedPairsAccordion.classList.add("hidden");
            sequenceSummary.classList.add("hidden");
        }

        let entityPairs = [];
        let isSequenceMigration = false;

        if (sequenceName) {
            isSequenceMigration = true;
            logsContainer.innerHTML += `<p><i class="fas fa-list-ol"></i> Loading sequence: <b>${sequenceName}</b>...</p>`;
            autoScrollLogs();

            const sequenceResponse = await fetch(`/get-migration-sequences/${sequenceName}`, {
                headers: {'Authorization': 'Bearer ' + localStorage.getItem('authToken')}
            });

            if (!sequenceResponse.ok) {
                throw new Error("Failed to load sequence details");
            }

            const sequence = await sequenceResponse.json();
            entityPairs = sequence.entity_names.map(pair => {
                const separator = pair.includes('-') ? '-' : ' ';
                const parts = pair.split(separator);
                return {
                    impower: parts[0].trim(),
                    crm: parts[1] ? parts[1].trim() : parts[0].trim()
                };
            });

            if (entityPairs.length === 0) {
                throw new Error("Selected sequence is empty");
            }

            logsContainer.innerHTML += `<p><i class="fas fa-check-circle"></i> Loaded sequence with ${entityPairs.length} pairs</p>`;
            
            // Initialize sequence progress
            document.getElementById("sequenceProgressBar").style.width = "0%";
            document.getElementById("sequenceProgressText").textContent = `0/${entityPairs.length}`;
        } else {
            const selectedimpowerEntity = $("#entitySelect").val();
            const selectedCrmEntity = $("#entitySelectCRM").val();
            
            if (!selectedimpowerEntity || !selectedCrmEntity) {
                throw new Error("Please select both source and target entities");
            }

            entityPairs = [{
                impower: selectedimpowerEntity,
                crm: selectedCrmEntity
            }];
        }

        // Track overall metrics
        let totalRecordsProcessed = 0;
        let totalErrors = 0;
        let totalSuccess = 0;
        let totalUpdates = 0;
        let totalCreates = 0;
        let totalDataSize = 0;
        const startTime = Date.now();

        // Process each entity pair
        for (const [index, pair] of entityPairs.entries()) {
            const { impower, crm } = pair;
            const pairNumber = isSequenceMigration ? ` (${index + 1}/${entityPairs.length})` : '';
            const pairStartTime = Date.now();

            logsContainer.innerHTML += `
                <div class="pair-header">
                    <i class="fas fa-arrow-right"></i> Starting migration${pairNumber}: 
                    <b>${impower}</b> - <b>${crm}</b>
                </div>
            `;
            autoScrollLogs();

            try {
                // Validate CRM entity
                if (!crm || crm.toLowerCase() === 'undefined') {
                    throw new Error(`Invalid CRM entity name: ${crm}`);
                }

                // Fetch matched fields
                logsContainer.innerHTML += `<p><i class="fas fa-info-circle"></i> Fetching matched fields...</p>`;
                autoScrollLogs();
                
                const matchedFieldsResponse = await fetch(
                    `/get-matching-fields?selectedimpowerEntity=${encodeURIComponent(impower)}&selectedCrmEntity=${encodeURIComponent(crm)}`, 
                    {
                        method: "GET",
                        headers: {"Authorization": `Bearer ${localStorage.getItem('authToken')}`}
                    }
                );

                if (!matchedFieldsResponse.ok) {
                    throw new Error("Failed to fetch matched fields");
                }

                const matchedFieldsData = await matchedFieldsResponse.json();
                const matchedFields = matchedFieldsData.matched_fields || [];

                // Check required fields coverage
                let coveragePercentage = "100%";
                try {
                    const crmFieldsResponse = await fetch(`/crm-entity-fields?entity_name=${encodeURIComponent(crm)}`, {
                        headers: {
                            "Authorization": `Bearer ${localStorage.getItem('authToken')}`,
                            "Content-Type": "application/json",
                        },
                    });
                    
                    if (crmFieldsResponse.ok) {
                        const crmFieldsData = await crmFieldsResponse.json();
                        if (crmFieldsData.success && crmFieldsData.columns) {
                            const mandatoryFields = crmFieldsData.columns
                                .filter(col => col?.mandatory && col.name)
                                .map(col => col.name.toString().toLowerCase().trim());
                            
                            const matchedCrmFields = matchedFields
                                .map(field => {
                                    const match = /-\s*([^*+]+)/.exec(field);
                                    return match ? match[1].toLowerCase().trim() : null;
                                })
                                .filter(field => field);
                            
                            const coveredMandatoryFields = mandatoryFields.filter(mandatoryField => 
                                matchedCrmFields.includes(mandatoryField)
                            ).length;
                            
                            coveragePercentage = mandatoryFields.length > 0 
                                ? ((coveredMandatoryFields / mandatoryFields.length) * 100).toFixed(2) + "%"
                                : "100%";
                        }
                    }
                } catch (error) {
                    console.error("Error calculating coverage:", error);
                    logsContainer.innerHTML += `<p><i class="fas fa-exclamation-triangle"></i> Warning: ${error.message}</p>`;
                }

                logsContainer.innerHTML += `<p><i class="fas fa-check-circle"></i> Required fields coverage: ${coveragePercentage}</p>`;
                autoScrollLogs();

                // Fetch source entity data
                logsContainer.innerHTML += `<p><i class="fas fa-info-circle"></i> Fetching data for <b>${impower}</b>...</p>`;
                autoScrollLogs();
                
                const entityDataResponse = await fetch(
                    `/get-entity-data?entity_name=${encodeURIComponent(impower)}`, 
                    {
                        method: "GET",
                        headers: {"Authorization": `Bearer ${localStorage.getItem('authToken')}`}
                    }
                );

                if (!entityDataResponse.ok) {
                    throw new Error("Failed to fetch entity data");
                }

                const entityData = await entityDataResponse.json();
                const totalRecords = entityData.total_records || entityData.data?.length || 0;
                const estimatedDataSize = totalRecords * 1024; // Approximate 1KB per record
                logsContainer.innerHTML += `<p><i class="fas fa-check-circle"></i> Found ${totalRecords} records (‚âà${formatBytes(estimatedDataSize)}) to migrate</p>`;
                autoScrollLogs();

                // Start migration
                document.getElementById("migrationMessage").textContent = `Preparing migration${pairNumber}...`;
                document.getElementById("migrationProgress").style.width = "0%";

                const response = await fetch("/migrate-entity", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${localStorage.getItem('authToken')}`
                    },
                    body: JSON.stringify({
                        selected_impower_entity: impower,
                        selected_crm_entity: crm,
                        limit_records: limitRecords ? 10 : null
                    }),
                });

                if (!response.ok) {
                    throw new Error(`Migration failed with status ${response.status}`);
                }

                const data = await response.json();
                const totalMigratedRecords = data.total_records || 0;
                const createdCount = data.insert_count || 0;
                const updatedCount = data.update_count || 0;
                let processedRecords = 0;

                // Process migration results
                for (const result of data.results || []) {
                    processedRecords++;
                    const progress = (processedRecords / totalMigratedRecords) * 100;
                    document.getElementById("migrationProgress").style.width = `${progress}%`;
                    document.getElementById("migrationMessage").textContent = 
                        `Migrating${pairNumber} record ${processedRecords} of ${totalMigratedRecords}`;

                    logsContainer.innerHTML += `
                        <div class="record-log">
                            <i class="fas fa-sync-alt"></i> Processing record <b>${processedRecords}</b> of <b>${totalMigratedRecords}</b>
                            <div class="record-details">
                                <span>ID: ${result.record_id || "N/A"}</span>
                                <span>Status: ${result.action === 'insert' ? 
                                    '<span class="text-green-600">Created</span>' : 
                                    '<span class="text-yellow-600">Updated</span>'}</span>
                                ${result.error ? `<span class="text-red-600">Error: ${result.error}</span>` : ''}
                            </div>
                        </div>
                    `;
                    autoScrollLogs();
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // Calculate pair metrics
                const pairDuration = ((Date.now() - pairStartTime) / 1000).toFixed(2);
                const velocity = totalMigratedRecords > 0 
                    ? (totalMigratedRecords / pairDuration).toFixed(2)
                    : "0";
                const successRate = totalMigratedRecords > 0
                    ? ((data.success_count || 0) / totalMigratedRecords * 100).toFixed(1)
                    : "0";
                const dataQuality = totalMigratedRecords > 0
                    ? ((totalMigratedRecords - (data.error_count || 0)) / totalMigratedRecords * 100).toFixed(1)
                    : "100";
                const dataSize = formatBytes(estimatedDataSize * (totalMigratedRecords / Math.max(totalRecords, 1)));

                // Update metrics
                totalRecordsProcessed += totalMigratedRecords;
                totalErrors += data.error_count || 0;
                totalSuccess += data.success_count || 0;
                totalUpdates += updatedCount;
                totalCreates += createdCount;
                totalDataSize += estimatedDataSize * (totalMigratedRecords / Math.max(totalRecords, 1));
                // Add to completed pairs
                const completedPair = document.createElement("div");
                completedPair.className = "completed-pair-item";
                let crmEntityLink = null;
                try {
                    const crmLinkResponse = await fetch(`/crm-entity-link?entity_name=${encodeURIComponent(crm)}`, {
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('authToken')}`
                        }
                    });
                    
                    if (crmLinkResponse.ok) {
                        const crmLinkData = await crmLinkResponse.json();
                        crmEntityLink = crmLinkData.crm_entity_link;
                    } else {
                        console.error(`Failed to get CRM link for ${crm}:`, crmLinkResponse.status);
                    }
                } catch (error) {
                    console.error(`Error fetching CRM link for ${crm}:`, error);
                }
                completedPair.innerHTML = `
                    <div class="completed-pair-header">
                        <div class="flex items-center justify-between w-full">
                            <span class="font-medium">${impower} - ${crm}</span>
                            <div class="flex items-center space-x-3">
                                <span class="text-sm">${pairDuration}s</span>
                                <div class="flex space-x-2">
                                    ${data.excel_file_url ? `
                                    <a href="${data.excel_file_url}" 
                                       class="excel-download-btn text-xs bg-green-100 hover:bg-green-200 text-green-800 px-2 py-1 rounded flex items-center transition-colors"
                                       download="${impower}_to_${crm}_migration.xlsx">
                                        <i class="fas fa-file-excel mr-1"></i> Excel
                                    </a>
                                    ` : ''}
                                    ${crmEntityLink ? `
                                    <a href="${crmEntityLink}" 
                                    target="_blank"
                                    class="crm-view-btn text-xs bg-blue-100 hover:bg-blue-200 text-blue-800 px-2 py-1 rounded flex items-center transition-colors">
                                        <i class="fas fa-external-link-alt mr-1"></i> View in CRM
                                    </a>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="completed-pair-metrics grid grid-cols-2 md:grid-cols-4 gap-2 mt-2">
                        <div class="metric-item">
                            <div class="metric-value">${totalMigratedRecords}</div>
                            <div class="metric-label">Records</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value text-green-600">${createdCount}</div>
                            <div class="metric-label">Created</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value text-yellow-600">${updatedCount}</div>
                            <div class="metric-label">Updated</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value ${data.error_count > 0 ? 'text-red-600' : ''}">${data.error_count || 0}</div>
                            <div class="metric-label">Errors</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${velocity}/s</div>
                            <div class="metric-label">Speed</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${dataQuality}%</div>
                            <div class="metric-label">Data Quality</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${dataSize}</div>
                            <div class="metric-label">Data Size</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${coveragePercentage}</div>
                            <div class="metric-label">Req. Fields</div>
                        </div>
                    </div>
                `;
                document.getElementById("completedPairsContainer").appendChild(completedPair);                
                if (isSequenceMigration) {
                    // Update sequence progress
                    const progress = ((index + 1) / entityPairs.length) * 100;
                    document.getElementById("sequenceProgressBar").style.width = `${progress}%`;
                    document.getElementById("sequenceProgressText").textContent = `${index + 1}/${entityPairs.length}`;
                }

                logsContainer.innerHTML += `
                    <div class="pair-result">
                        <i class="fas fa-check-circle"></i> Completed${pairNumber} in ${pairDuration}s:
                        <ul>
                            <li>Records: ${totalMigratedRecords}</li>
                            <li>Created: ${createdCount}</li>
                            <li>Updated: ${updatedCount}</li>
                            <li>Errors: ${data.error_count || 0}</li>
                            <li>Speed: ${velocity} records/sec</li>
                            <li>Data Quality: ${dataQuality}%</li>
                        </ul>
                    </div>
                `;
                autoScrollLogs();

            } catch (pairError) {
                logsContainer.innerHTML += `
                    <div class="pair-error">
                        <i class="fas fa-times-circle"></i> Failed${pairNumber}:
                        ${pairError.message}
                    </div>
                `;
                autoScrollLogs();
                if (!isSequenceMigration) throw pairError;
                continue;
            }
        }

        // Final metrics
        const totalDuration = ((Date.now() - startTime) / 1000).toFixed(2);
        const velocity = totalRecordsProcessed > 0 
            ? (totalRecordsProcessed / totalDuration).toFixed(2)
            : "0";
        const successRate = totalRecordsProcessed > 0
            ? ((totalSuccess / totalRecordsProcessed) * 100).toFixed(2)
            : "0";
        const dataQuality = totalRecordsProcessed > 0
            ? ((totalRecordsProcessed - totalErrors) / totalRecordsProcessed * 100).toFixed(1)
            : "100";

        // Show sequence summary if applicable
        if (isSequenceMigration) {
            sequenceSummary.classList.remove("hidden");
            document.getElementById("totalSequenceDuration").textContent = `${totalDuration}s`;
            document.getElementById("totalSequenceRecords").textContent = totalRecordsProcessed;
            
            logsContainer.innerHTML += `
                <div class="sequence-summary">
                    <i class="fas fa-flag-checkered"></i> Sequence <b>${sequenceName}</b> completed in ${totalDuration}s
                    <ul>
                        <li>Total records: ${totalRecordsProcessed}</li>
                        <li>Created: ${totalCreates}</li>
                        <li>Updated: ${totalUpdates}</li>
                        <li>Data Quality: ${dataQuality}%</li>
                        <li>Total Data Size: ${formatBytes(totalDataSize)}</li>
                        <li>Average Speed: ${velocity} records/sec</li>
                    </ul>
                </div>
            `;
        } else {
            logsContainer.innerHTML += `
                <div class="migration-summary">
                    <i class="fas fa-flag-checkered"></i> Migration completed in ${totalDuration}s
                    <ul>
                        <li>Records processed: ${totalRecordsProcessed}</li>
                        <li>Created: ${totalCreates}</li>
                        <li>Updated: ${totalUpdates}</li>
                        <li>Data Quality: ${dataQuality}%</li>
                        <li>Total Data Size: ${formatBytes(totalDataSize)}</li>
                        <li>Average Speed: ${velocity} records/sec</li>
                    </ul>
                </div>
            `;
        }
        autoScrollLogs();

        // Show metrics section
        metricsSection.style.display = "block";
        document.getElementById("migrationMessage").textContent = "Complete";
        setTimeout(resetProgressBars, 1000);

    } catch (error) {
        console.error("Migration error:", error);
        logsContainer.innerHTML += `
            <div class="error-summary">
                <i class="fas fa-times-circle"></i> Migration failed:
                ${error.message}
            </div>
        `;
        autoScrollLogs();
        document.getElementById("migrationMessage").textContent = "Error";
    } finally {
        document.getElementById("progressContainer").style.display = "none";
        hideLoadingSpinner();
    }
});

// Helper function to format bytes
function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}
function autoScrollLogs() {
            const logsContainer = document.getElementById("logsContainer");
            logsContainer.scrollTop = logsContainer.scrollHeight; // Scroll to the bottom
        }




        document.getElementById("authForm").addEventListener("submit", async (e) => {
            e.preventDefault(); // Prevent default form submission
            
            const apiKey = document.getElementById("apiKey").value;
            if (!apiKey) {
                alert("Please enter your API key.");
                return;
            }
            
            showLoadingSpinner();
            try {
                const response = await fetch("/authenticate", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ api_key: apiKey }),
                });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || "Connection failed.");
                }
        
                const data = await response.json();
                accessToken = data.access_token; // Store token globally
                console.log('access_token - ', accessToken)
                // Hide auth form and show migration interface
                document.getElementById("authForm").style.display = "none";
                document.getElementById("migrationSection").style.display = "block";
                document.getElementById("matchControls").style.display = "block";
                document.getElementById("progressContainer").style.display = "block";
                document.getElementById("logsSection").style.display = "block";
                document.getElementById("entityControls").style.display = "flex";
                document.getElementById("matchingControls").style.display = "block";
                document.getElementById("progressContainer").style.display = "none";
        
                await fetchAndPopulateCrmEntities();
                await populateEntityDropdown();
        
            } catch (error) {
                console.error("Error during connection:", error);
                alert(`Connection failed: ${error.message}`);
            } finally {
                hideLoadingSpinner();
            }
        });
        

        document.getElementById("authenticateBtn").addEventListener("click", async () => {
            const apiKey = document.getElementById("apiKey").value;
            if (!apiKey) {
                alert("Please enter your API key.");
                return;
            }
            
            showLoadingSpinner();
            try {
                const response = await fetch("/authenticate", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ api_key: apiKey }),
                });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || "Connection failed.");
                }
        
                const data = await response.json();
                accessToken = data.access_token; // Store token globally
                
                // Hide auth form and show migration interface
                document.getElementById("authForm").style.display = "none";
                document.getElementById("migrationSection").style.display = "block";
                document.getElementById("matchControls").style.display = "block";
                document.getElementById("progressContainer").style.display = "block";
                document.getElementById("logsSection").style.display = "block";
                document.getElementById("entityControls").style.display = "flex";
                document.getElementById("matchingControls").style.display = "block";
                document.getElementById("progressContainer").style.display = "none";
        
                await fetchAndPopulateCrmEntities();
                await populateEntityDropdown();
        
            } catch (error) {
                console.error("Error during connection:", error);
                alert(`Connection failed: ${error.message}`);
            } finally {
                hideLoadingSpinner();
            }
        });
        
        
        async function fetchAndPopulateCrmEntities() {
            try {
                // Fetch CRM entities from the backend
                const response = await fetch("/getfromdb-crm-entities", {
                    method: "GET",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json"
                    }
                });
        
                // Check if the response is OK
                if (!response.ok) {
                    throw new Error("Failed to fetch CRM entities");
                }
        
                // Parse the response JSON
                const data = await response.json();
        
                // Validate the response structure
                if (!Array.isArray(data)) {
                    throw new Error("Invalid API response format");
                }
        
                // Get the dropdown element
                const entitySelectCRM = document.getElementById("entitySelectCRM");
        
                // Clear existing options
                entitySelectCRM.innerHTML = '<option value="">-- Select a CRM Entity --</option>';
        
                // Populate the dropdown with CRM entities
                data.forEach(entity => {
                    const option = document.createElement("option");
                    option.value = entity.entity_name; // Use entity_name as the value
                    option.textContent = entity.entity_name.replace(/-/g, " "); // Replace hyphens with spaces for display
                    if (!entity.is_active) {
                        option.disabled = true; // Disable the option if the entity is not active
                    }
                    entitySelectCRM.appendChild(option);
                });
                sortSelectOptions("entitySelectCRM"); // Sort after population

                console.log("CRM entities loaded successfully.");
            } catch (error) {
                console.error("Error fetching CRM entities:", error);
                alert("Failed to fetch CRM entities. Please try again.");
            }
        }
    
        function sortSelectOptions(selectId) {
            const select = document.getElementById(selectId);
            const options = Array.from(select.options);
    
            // Exclude the first option (e.g., "-- Select --")
            const sortedOptions = options.slice(1).sort((a, b) => 
                a.text.localeCompare(b.text)
            );
    
            // Clear the select and re-add the default option
            select.innerHTML = "";
            select.appendChild(options[0]);
    
            // Append sorted options
            sortedOptions.forEach(option => select.appendChild(option));
        }
    
        document.addEventListener("DOMContentLoaded", () => {
            if (accessToken) {
                fetchAndPopulateCrmEntities();
                populateEntityDropdown();
            }
        });
        
    async function populateEntityDropdown() {
            try {
                const response = await fetch("/get-impower-entities-with-status", {
                    method: "GET",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json",
                    },
                });
                if (!response.ok) {throw new Error("Failed to fetch entities list");}
                const entities = await response.json();
                const entitySelect = document.getElementById("entitySelect");
                entitySelect.innerHTML = '<option value="">-- Select a impower Entity --</option>';
                entities.forEach(entity => {
                    const option = document.createElement("option");
                    option.value = entity.entity_name;
                    option.textContent = entity.entity_name.replace(/-/g, " ");
                    if (!entity.has_data) {option.disabled = true;}
                    entitySelect.appendChild(option);
                });
                sortSelectOptions("entitySelect"); // Sort after population

            } catch (error) {
                console.error("Error fetching entities list:", error);
                alert("Failed to fetch impower entities. Please try again.");
            }
        }
        
        async function fetchEntitiesList() {
            try {
                const response = await fetch("/impower-entities");
                if (!response.ok) {throw new Error("Failed to fetch entities list");}
                const entities = await response.json();
                return entities;
            } catch (error) {
                console.error("Error fetching entities list:", error);
                return []; // Return an empty array or handle the error as needed
            }
        }

            document.getElementById("fetchEntityBtnCRM").addEventListener("click", async () => {
                const entitySelect = document.getElementById("entitySelectCRM");
                const selectedEntity = entitySelect.value;
                if (!selectedEntity) {
                    alert("Please select a CRM entity.");
                    return;
                }

                const logsContainer = document.getElementById("logsContainer");
                logsContainer.innerHTML = `<p><i class="fas fa-info-circle"></i> Fetching column names for CRM entity: ${selectedEntity}...</p>`;
                autoScrollLogs();
                logsContainer.style.display = "block";

                try {
                    const response = await fetch(`/crm-entity-fields?entity_name=${selectedEntity}`, {
                        method: "GET",
                        headers: {
                            "Authorization": `Bearer ${accessToken}`,
                            "Content-Type": "application/json",
                        },
                    });
                    if (!response.ok) {throw new Error("Failed to fetch CRM entity fields");}
                    const data = await response.json();
                    if (data.success) {
                        logsContainer.innerHTML += `<p><i class="fas fa-list"></i> Entity Columns:</p>`;
                        // Build the formatted list of columns with mandatory fields highlighted
                        let columnListHTML = "<ul>";
                        data.columns.forEach(column => {
                            if (column.mandatory) {
                                columnListHTML += `<li style="color: red;">${column.name} *</li>`; // Red color for required fields
                            } 
                            
                        // Check if the column has upsert = true
                        else if (column.upsert) {
                            columnListHTML += `<li style="color: green;">${column.name} + </li>`; // Green color for upsert fields
                        } 
                            
                            else {columnListHTML += `<li>${column.name}</li>`;}
                        });
                        columnListHTML += "</ul>";
                        logsContainer.innerHTML += columnListHTML;
                        autoScrollLogs();
                    } else {
                        logsContainer.innerHTML += `<p><i class="fas fa-times-circle"></i> Failed to fetch columns for ${selectedEntity}.</p>`;
                        autoScrollLogs();
                    }
                } catch (error) {
                    console.error("Error:", error);
                    logsContainer.innerHTML += `<p><i class="fas fa-times-circle"></i> An error occurred while fetching columns for ${selectedEntity}.</p>`;
                    autoScrollLogs();
                }
            });
                
        // Fetch data for the selected entity
        async function fetchEntityData(entityName) {
            try {
                const response = await fetch(`/fetch-and-save-entity?entity_name=${entityName}`, {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json",
                    },
                });
                if (!response.ok) {throw new Error("Failed to fetch entity data");}
                const data = await response.json();return data;
            } catch (error) {console.error("Error fetching entity data:", error);throw error;}
        }

        document.getElementById("fetchEntityBtn").addEventListener("click", async () => {
            const entitySelect = document.getElementById("entitySelect");
            const selectedEntity = entitySelect.value;
            const logsContainer = document.getElementById("logsContainer");

            if (!selectedEntity) {
                alert("Please select an entity.");
                return;
            }
            showLoadingSpinner();
            logsContainer.innerHTML = "";
            logsContainer.style.display = "block";
            logsContainer.innerHTML += `<p><i class="fas fa-info-circle"></i> Fetching data for entity: ${selectedEntity}...</p>`;
            autoScrollLogs();
            try {
                // Real-time progress tracking for fetching data
                document.getElementById("fetchingMessage").textContent = `Fetching ${selectedEntity}...`;
                document.getElementById("fetchingProgress").style.width = "0%";
                const eventSource = new EventSource(`/stream-progress?entity_name=${selectedEntity}`);
                eventSource.onmessage = function (event) {
                    const progress = parseInt(event.data);
                    document.getElementById("fetchingProgress").style.width = `${progress}%`;
                    document.getElementById("fetchingMessage").textContent = `Fetching ${selectedEntity}... ${progress}%`;
                    if (progress === 100) {
                        eventSource.close();
                        logsContainer.innerHTML += `<p><i class="fas fa-check-circle"></i> Data fetched successfully for ${selectedEntity}.</p>`;
                        autoScrollLogs();
                        fetchTotalRows(selectedEntity);
                        setTimeout(() => {
                            document.getElementById("fetchingProgress").style.width = "0%";
                            document.getElementById("fetchingMessage").textContent = "Not Started";
                        }, 1000);
                    }
                };

                // Step 1: Fetch & save entity data
                const fetchResponse = await fetch(`/fetch-and-save-entity?entity_name=${selectedEntity}`, {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json",
                    },
                });

                if (!fetchResponse.ok) throw new Error("Failed to fetch entity data");

                const fetchData = await fetchResponse.json();
                if (fetchData.success) {
                    logsContainer.innerHTML += `<p><i class="fas fa-list"></i> Entity Columns:</p>`;
                    // Check if columns exist and is an array before joining
                    if (fetchData.columns && Array.isArray(fetchData.columns)) {
                        logsContainer.innerHTML += `<pre>${fetchData.columns.join("\n")}</pre>`;
                    } else {
                        logsContainer.innerHTML += `<pre>No columns information available</pre>`;
                    }
                    autoScrollLogs();
                }

                // Step 2: Fetch & export entity data (only after fetch-and-save is successful)
                logsContainer.innerHTML += `<p><i class="fas fa-info-circle"></i> Exporting data for entity: ${selectedEntity}...</p>`;
                autoScrollLogs();

                const exportResponse = await fetch("/fetch-and-export/", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ entity_name: selectedEntity }),
                });

                if (!exportResponse.ok) throw new Error("Failed to export entity data");

                const exportData = await exportResponse.json();
                if (exportData.success) {
                    // Update the Excel download link
                    if (exportData.excel_file_url) {
                        const excelLink = document.getElementById("excelLink");
                        excelLink.href = exportData.excel_file_url;
                    }
                    document.getElementById("excelDownload").style.display = "block";

                    autoScrollLogs();
                } else {
                    throw new Error(`Failed to export data for ${selectedEntity}`);
                }

            } catch (error) {
                logsContainer.innerHTML += `<p><i class="fas fa-times-circle"></i> Error: ${error.message}</p>`;
                autoScrollLogs();
            } finally {
                hideLoadingSpinner();
            }
        });

                
            let clickCount = 0;
            let clickCount2 = 0;
            let clickCount3 = 0;

            const maxClicksForExport = 3;
            const maxClicksForStatusUpdate = 4;
            const maxClicksForCRMList=5;
            const clickableHeading = document.getElementById("clickableHeading");
            const logsContainer = document.getElementById("logsContainer");
            
            // Function to add logs to the logs container
            function addLog(message) {
                const logEntry = document.createElement("p");
                logEntry.innerHTML = `<i class="fas fa-info-circle"></i> ${message}`;
                logsContainer.appendChild(logEntry);
                autoScrollLogs();
            }
            // Function to update the progress bar
            function updateProgress(percentage) {
                document.getElementById("fetchingProgress").style.width = `${percentage}%`;
            }            
            // Function to fetch and download the Excel file
            async function fetchAndDownloadExcel() {
                try {
                    addLog("Starting the download process...");updateProgress(10);
                    const response = await fetch("/fetch-and-export_all_entities/", {
                        method: "POST",
                        headers: {"Content-Type": "application/json",},
                        body: JSON.stringify({ access_token: accessToken }),
                    });
                    if (!response.ok) {throw new Error("Failed to fetch Excel file.");}
                    const data = await response.json();
                    addLog("Excel file generated successfully.");updateProgress(50);
                    const excelFileUrl = data.excel_file_url;
                    addLog(`Downloading Excel file from: ${excelFileUrl}`);updateProgress(75);
                    const downloadResponse = await fetch(excelFileUrl);
                    if (!downloadResponse.ok) {throw new Error("Failed to download Excel file.");}
                    const blob = await downloadResponse.blob();
                    const downloadLink = document.createElement("a");
                    downloadLink.href = URL.createObjectURL(blob);
                    downloadLink.download = "impower_export.xlsx";
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    addLog("Excel file downloaded successfully.");updateProgress(100);
                } catch (error) {addLog(`Error: ${error.message}`);updateProgress(0);}
            }
            
            // Function to update impower_entities_with_status table
            async function updateimpowerEntitiesStatus() {
                try {
                    addLog("Updating impower_entities_with_status...");updateProgress(10);
                    const response = await fetch("/impower-entities-with-status", {
                        method: "POST",
                        headers: {"Content-Type": "application/json",},
                        body: JSON.stringify({ access_token: accessToken }),
                    });
                    if (!response.ok) {throw new Error("Failed to update entity status.");}
                    addLog("impower_entities_with_status updated successfully.");
                    await populateEntityDropdown();updateProgress(100);
                } catch (error) {
                    addLog(`Error: ${error.message}`);updateProgress(0);
                }
            }
            
            async function updateCRMEntitiesList() {
                try {
                    addLog("Updating crm_entities...");
                    updateProgress(10);
            
                    const response = await fetch("/crm-entities-table-save", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer ${accessToken}`, // Send token in the Authorization header
                        }
                    });
            
                    if (!response.ok) {
                        throw new Error("Failed to update entity status.");
                    }
            
                    const data = await response.json();
                    addLog("crm_entities updated successfully.");
                    
                    // Log the fetched entities
                    if (data.entities && data.entities.length > 0) {
                        addLog(`Fetched ${data.entities.length} entities.`);
                    } else {
                        addLog("No CRM entities found.");
                    }
            
                    await populateEntityDropdown();
                    updateProgress(100);
                } catch (error) {
                    addLog(`Error: ${error.message}`);
                    updateProgress(0);
                }
            }
            

            // Handle heading click
            clickableHeading.addEventListener("click", () => {
                clickCount++;
                clickCount2++;
                clickCount3++;
                addLog(`Heading clicked to download excel file ${clickCount} time(s).`);
                addLog(`Heading clicked for impower entities updated ${clickCount2} time(s).`);
                addLog(`Heading clicked for crm entities updated ${clickCount3} time(s).`);

                if (clickCount === maxClicksForExport) {
                    fetchAndDownloadExcel();
                    clickCount = 0;
                } 
                else if (clickCount2 === maxClicksForStatusUpdate) {
                    updateimpowerEntitiesStatus();
                    clickCount2 = 0;
                }
                else if (clickCount3 === maxClicksForCRMList) {
                    updateCRMEntitiesList();
                    clickCount3 = 0;
                }
            });
            
        async function fetchTotalRows(entityName) {
            try {
                const response = await fetch(`/get-total-rows?entity_name=${entityName}`, {
                    method: "GET",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                    },
                });

                if (!response.ok) {
                    throw new Error("Failed to fetch total rows.");
                }

                const data = await response.json();
                const logsContainer = document.getElementById("logsContainer");
                logsContainer.innerHTML += `<p><i class="fas fa-database"></i> Total rows fetched for ${entityName}: ${data.total_records}</p>`;
                autoScrollLogs();
            } catch (error) {
                console.error("Error fetching total rows:", error);
                const logsContainer = document.getElementById("logsContainer");
                logsContainer.innerHTML += `<p><i class="fas fa-times-circle"></i> Failed to fetch total rows for ${entityName}.</p>`;
                autoScrollLogs();
            }
        }




        async function getCrmContactsUrl() {
            try {
                const response = await fetch('/api/crm-contacts-url');
                if (!response.ok) {throw new Error('Failed to fetch CRM contacts URL');}
                const data = await response.json();
                return data.crmContactsUrl;
            } catch (error) {console.error('Error fetching CRM contacts URL:', error);return null;}
        }
        function resetProgressBars() {
            document.getElementById("fetchingProgress").style.width = "0%";
            document.getElementById("migrationProgress").style.width = "0%";
            document.getElementById("fetchingMessage").textContent = "Fetching : Not Started";
            document.getElementById("migrationMessage").textContent = "Migration: Not Started";
            document.getElementById("fetchingMessage").textContent = "Pending";
            document.getElementById("migrationMessage").textContent = "Pending";
        }
        function showLoadingSpinner() {
            $("#loadingSpinner").show(); 
        }
        
        function hideLoadingSpinner() {
            $("#loadingSpinner").hide();
        }

        document.addEventListener('DOMContentLoaded', function() {
            let draggedItem = null;
        
            // Initialize drag and drop containers
            const initDragDrop = (container) => {
                container.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('drag-item')) {
                        draggedItem = e.target;
                        e.target.style.opacity = '0.5';
                        e.dataTransfer.setData('text/plain', e.target.textContent);
                    }
                });
        
                container.addEventListener('dragend', (e) => {
                    if (e.target.classList.contains('drag-item')) {
                        e.target.style.opacity = '1';
                        draggedItem = null;
                    }
                });
        
                container.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const afterElement = getDragAfterElement(container, e.clientY);
                    const draggable = draggedItem;
                    
                    if (afterElement == null) {
                        container.appendChild(draggable);
                    } else {
                        container.insertBefore(draggable, afterElement);
                    }
                });
            };
        
            function loadSavedSequences() {
                return fetch('/get-migration-sequences/', {
                    headers: {
                        'Authorization': 'Bearer ' + localStorage.getItem('authToken')
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(sequences => {
                    const select = document.getElementById('selectedSequence');
                    const currentValue = select.value; // Remember current selection
                    
                    // Clear existing options
                    select.innerHTML = '<option value="">-- Select a sequence --</option>';
                    
                    // Add new options
                    sequences.forEach(seq => {
                        const option = new Option(seq.order_name, seq.order_name);
                        select.add(option);
                    });
                    
                    // Restore selection if it still exists
                    if (currentValue && Array.from(select.options).some(opt => opt.value === currentValue)) {
                        select.value = currentValue;
                    }
                    
                    return sequences; // Return the sequences for chaining
                })
                .catch(error => {
                    console.error('Error loading sequences:', error);
                    alert('Error loading sequences: ' + error.message);
                    throw error; // Re-throw for chaining
                });
            }
                    
            // Helper function to determine drop position
            const getDragAfterElement = (container, y) => {
                const draggableElements = [...container.querySelectorAll('.drag-item:not(.dragging)')];
                
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            };
        
            // Create a draggable item
            const createDraggableItem = (text) => {
                const div = document.createElement('div');
                div.className = 'drag-item bg-gray-50 p-2 mb-1 rounded cursor-move border hover:bg-gray-100';
                div.draggable = true;
                div.textContent = text;
                return div;
            };
        
            // Load available entity pairs from matching_table
            fetch('/get-matching-entities/', {
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem('authToken')
                }
            })
            .then(response => response.json())
            .then(data => {
                const container = document.getElementById('availableEntities');
                data.forEach(entity => {
                    container.appendChild(createDraggableItem(entity));
                });
            })
            .catch(error => console.error('Error loading entities:', error));
        
            // Initialize drag and drop for both containers
            initDragDrop(document.getElementById('availableEntities'));
            initDragDrop(document.getElementById('currentSequence'));
        
            // Button event handlers
            document.getElementById('saveSequenceBtn').addEventListener('click', saveSequence);
            document.getElementById('deleteSequenceBtn').addEventListener('click', deleteSelectedSequence);
            
            // Fixed dropdown change handler
            document.getElementById('selectedSequence').addEventListener('change', function() {
                const sequenceName = this.value;
                const deleteBtn = document.getElementById('deleteSequenceBtn');
                const hasSelection = sequenceName !== '';
                
                deleteBtn.disabled = !hasSelection;
        
                // Load the sequence when selected
                if (hasSelection) {
                    loadSequenceIntoEditor(sequenceName);
                } else {
                    // Clear the editor if no sequence is selected
                    document.getElementById('sequenceName').value = '';
                    document.getElementById('currentSequence').innerHTML = '';
                }
            });
        
            // Load saved sequences on page load
            loadSavedSequences();
        
            function saveSequence() {
                const nameInput = document.getElementById('sequenceName');
                const name = nameInput.value.trim();
                const entities = Array.from(document.getElementById('currentSequence').children)
                    .map(item => item.textContent.trim())
                    .filter(item => item); // Remove empty items
            
                console.debug("Saving sequence:", {name, entities});
            
                // Validation
                if (!name) {
                    alert('Sequence name cannot be empty');
                    nameInput.focus();
                    return;
                }
                
                if (entities.length === 0) {
                    alert('Please add at least one entity to the sequence');
                    return;
                }
            
                const saveBtn = document.getElementById('saveSequenceBtn');
                const originalText = saveBtn.innerHTML;
                
                // Set loading state
                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
                saveBtn.disabled = true;
            
                fetch('/create-migration-sequence/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('authToken')}`
                    },
                    body: JSON.stringify({
                        order_name: name,
                        entity_names: entities
                    })
                })
                .then(async response => {
                    const data = await response.json();
                    if (!response.ok) {
                        console.error("Save failed:", data);
                        throw new Error(data.detail || `Save failed with status ${response.status}`);
                    }
                    return data;
                })
                .then(data => {
                    console.log("Save successful:", data);
                    // Refresh the sequence list
                    return loadSavedSequences().then(() => {
                        // Re-select the current sequence
                        const select = document.getElementById('selectedSequence');
                        select.value = name;
                        select.dispatchEvent(new Event('change'));
                        alert(data.message || 'Sequence saved successfully');
                    });
                })
                .catch(error => {
                    console.error("Save error:", error);
                    alert(`Error: ${error.message}`);
                })
                .finally(() => {
                    saveBtn.innerHTML = originalText;
                    saveBtn.disabled = false;
                });
            }
            
            
            
            function loadSequenceIntoEditor(sequenceName) {
                console.log("Loading sequence:", sequenceName);
                fetch('/get-migration-sequences/', {
                    headers: {
                        'Authorization': 'Bearer ' + localStorage.getItem('authToken')
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to load sequences');
                    }
                    return response.json();
                })
                .then(sequences => {
                    const sequence = sequences.find(s => s.order_name === sequenceName);
                    if (sequence) {
                        console.log("Found sequence:", sequence);
                        document.getElementById('sequenceName').value = sequence.order_name;
                        
                        const currentSequence = document.getElementById('currentSequence');
                        currentSequence.innerHTML = '';
                        
                        sequence.entity_names.forEach(entity => {
                            currentSequence.appendChild(createDraggableItem(entity));
                        });
                    } else {
                        console.error("Sequence not found:", sequenceName);
                        alert("Sequence not found!");
                    }
                })
                .catch(error => {
                    console.error('Error loading sequence:', error);
                    alert('Error loading sequence details: ' + error.message);
                });
            }
            
            async function deleteSelectedSequence() {
                const sequenceName = document.getElementById('selectedSequence').value;
                if (!sequenceName) {
                    alert('Please select a sequence to delete');
                    return;
                }
                
                if (!confirm(`Are you sure you want to delete the sequence "${sequenceName}"?`)) {
                    return;
                }
                
                const deleteBtn = document.getElementById('deleteSequenceBtn');
                const originalBtnText = deleteBtn.innerHTML;
                
                try {
                    // Show loading state
                    deleteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Deleting...';
                    deleteBtn.disabled = true;
                    
                    const response = await fetch('/delete-migration-sequence/', {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + localStorage.getItem('authToken')
                        },
                        body: JSON.stringify({ order_name: sequenceName })
                    });
            
                    // First check if response is OK
                    if (!response.ok) {
                        // Try to parse error response
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.detail || errorData.message || `Failed to delete sequence (status ${response.status})`);
                    }
            
                    // If OK, parse success response
                    const result = await response.json();
                    
                    // Clear form
                    document.getElementById('selectedSequence').value = '';
                    document.getElementById('sequenceName').value = '';
                    document.getElementById('currentSequence').innerHTML = '';
                    
                    // Refresh dropdown
                    await loadSavedSequences();
                    
                    alert(result.message || 'Sequence deleted successfully');
                } catch (error) {
                    console.error('Delete error:', error);
                    alert('Error deleting sequence: ' + error.message);
                } finally {
                    // Restore button state
                    deleteBtn.innerHTML = originalBtnText;
                    deleteBtn.disabled = true;
                }
            }
        });

let hasChanges = false;
const saveBtn = document.getElementById('saveSequenceBtn');
const deleteBtn = document.getElementById('deleteSequenceBtn');
const sequenceContainer = document.getElementById('currentSequence');
const sequenceDropdown = document.getElementById('sequenceDropdown'); // Assuming dropdown ID

// Initialize buttons as disabled
updateButtonStates();

// MutationObserver to detect changes in the sequence
const observer = new MutationObserver(() => {
  if (!hasChanges) {
    hasChanges = true;
    updateButtonStates();
  }
});

observer.observe(sequenceContainer, {
  childList: true,
  subtree: true,
  attributes: false,
  characterData: false
});

// Track drag-and-drop operations
let draggedItem = null;

sequenceContainer.addEventListener('dragstart', (e) => {
  draggedItem = e.target;
});

sequenceContainer.addEventListener('dragover', (e) => {
  e.preventDefault(); // Allow drop
});

sequenceContainer.addEventListener('drop', (e) => {
  e.preventDefault();
  if (draggedItem && e.target !== draggedItem) {
    const rect = e.target.getBoundingClientRect();
    const dropPosition = e.clientY < rect.top + rect.height / 2 ? 'before' : 'after';
    
    if (dropPosition === 'before') {
      e.target.before(draggedItem);
    } else {
      e.target.after(draggedItem);
    }
    
    hasChanges = true;
    updateButtonStates();
  }
});

// Track manual additions/removals
document.getElementById('availableEntities').addEventListener('dragend', () => {
  if (sequenceContainer.children.length > 0) {
    hasChanges = true;
    updateButtonStates();
  }
});

// Prevent dropdown selection from enabling buttons
sequenceDropdown.addEventListener('change', () => {
  hasChanges = false; // Reset changes since no drag-and-drop occurred
  updateButtonStates();
});

// Button state updater
function updateButtonStates() {
  if (hasChanges) {
    saveBtn.classList.remove('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
    saveBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white', 'cursor-pointer');
    saveBtn.disabled = false;
    
    deleteBtn.classList.remove('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
    deleteBtn.classList.add('bg-red-500', 'hover:bg-red-600', 'text-white', 'cursor-pointer');
    deleteBtn.disabled = false;
  } else {
    saveBtn.classList.add('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
    saveBtn.classList.remove('bg-green-500', 'hover:bg-green-600', 'text-white', 'cursor-pointer');
    saveBtn.disabled = true;
    
    deleteBtn.classList.add('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
    deleteBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'text-white', 'cursor-pointer');
    deleteBtn.disabled = true;
  }
}

// Reset changes after operations
saveBtn.addEventListener('click', () => {
  hasChanges = false;
  updateButtonStates();
});

deleteBtn.addEventListener('click', () => {
  hasChanges = false;
  updateButtonStates();
});

    </script>
</body>
</html>